**二、离散仿真引擎基础**

1.简答题

（1）*GameObject 游戏对象* 是Unity的场景里面所有实体的基类，即游戏里出现的所有东西都是游戏对象。

*Asset 资源* 则是游戏使用的各种资源，包括图片、声音、材质、脚本代码文件等。

两者都会在游戏运行时被加载；且一个游戏对象可以使用不同资源作为组件、模板，一个资源可以被不同游戏对象使用。

（2）*资源的目录组织结构*：Assets根目录下包括Materials、Textures、Images、3DModels、Audios等分类文件夹，每个文件夹下放入相应类型的资源文件，有的还有更细的分类文件夹。

*游戏对象的层次结构*：根场景对象下包括Cameras、UI、Characters、Lights等在该场景出现的底层父对象，再里面则是父对象的一些针对不同部分如空间的细化的子对象。

（3）

    public class NewBehaviourScript : MonoBehaviour {

    void Awake() {
        Debug.Log("Awake!");
    }
    void Start() {
        Debug.Log("Start!");
    }
    void Update() {
        Debug.Log("Update!");
    }
    void FixedUpdate() {
        Debug.Log("FixedUpdate!");
    }
    void LateUpdate() {
        Debug.Log("LateUpdate!");
    }
    void OnGUI() {
        Debug.Log("OnGUI!");
    }
    void OnEnable() {
        Debug.Log("OnEnable!");
    }
    void OnDisable() {
        Debug.Log("OnDisable!");
    }
    }

（4）*GameObject*：Unity场景里面所有实体的基类。

*Transform*：对象的位置、旋转和缩放。场景中的每一个对象都有一个Transform。用于储存并操控物体的位置、旋转和缩放。每一个Transform可以有一个父级，允许你分层次应用位置、旋转和缩放。可以在Hierarchy面板查看层次关系。他们也支持计数器，因此你可以使用循环遍历子对象。

*Component*：所有附件到游戏对象的基类。请注意，您的代码将永远不会直接创建一个组件。而是，你写脚本代码，附加脚本到一个游戏对象上。

table的属性：activeSelf = true（第一个选择框）, name = table（文本框）, IsStatic = false（名字右边的选择框）, layer = Default（Static下面的Layer）, tag = Untagged（名字下面的Tag）, Transform = 默认Transform部件（table属性下面）

table 的 Transform 的属性：Position坐标位置为（0，0，0），Rotation旋转为（0，0，0），Scale放大倍数为（1，1，1）

table 的部件：Cube(Mesh Filter)，Box Collider，MeshRenderer，Default-Material
 
[UML图](https://github.com/465924212/3D-Game-Programming-Design/blob/master/2.4.png)

（5）

查找对象：

找到并返回一个名字为name的游戏物体

    public class ExampleClass : MonoBehaviour {
        public GameObject answer;
        void Find() {
            answer = GameObject.Find("name");
        }
    }

返回具体tag标签的激活的游戏对象列表

    public class ExampleClass : MonoBehaviour {
        public GameObject answers;
        public Object answer;
        void FindGameObjectsWithTag() {
                 answer = GameObject.FindGameObjectsWithTag("Respawn");
         }
     }

返回标记为tag的一个游戏对象

    public class ExampleClass : MonoBehaviour {
        public GameObject answers;
        public Object answer;
        void FindWithTag() {
                answer = GameObject.FindWithTag("Respawn");
        }
    }

添加子对象：

    public class ExampleClass : MonoBehaviour {
        void Start() {
            GameObject plane = GameObject.CreatePrimitive(PrimitiveType.Plane);
        }
    }

遍历对象树：

    foreach (Object child in tree) {
	    //do something
    }

清除所有子对象：

    foreach (Object child in tree) {
	    Destroy(child);
    }

（6）*Prefabs预设*可以作为游戏对象的模板，方便重复利用；修改预设可以同时修改在场景中添加的所有对象实例，不会造出不同但无法同时编辑的游戏对象实例。 

预设能在做到克隆的同时，对预设进行修改能修改其所有实例，而克隆则不能。

    public Rigidbody table;

    void InitiateTable () {
        Rigidbody tableClone = (Rigidbody) Instantiate(table, transform.position, transform.rotation);
    }

（7）组合模式是一种设计模式，描述了一组对象被当成一个同样类型的对象实例来对待的模式，目的是把对象组合成树状来描述“部分-整体”的结构。

    public class ExampleClass : MonoBehaviour {
        void Example() {
            gameObject.BroadcastMessage("Test Message!");
        }
    }
