五、1.本次小游戏制作的“鼠标打飞碟”小游戏（又名鼠标点击平抛小球），利用之前“牧师与魔鬼”小游戏搭建好的模型（director, scene controller, usergui, action manager)，加上工厂类管理游戏对象以及计分器计算分数，因为游戏逻辑比较简单，这样就差不多做好了。原先模型里，director作为游戏中只有一个实例的类，不需要挂载在游戏对象上，在被调用时自动生成实例，其中储存有一个ISceneController的接口实例，供其他所有类调用scene controller中与游戏内容相关的方法。这个类在不同游戏中都差不多，区别大概是GameOver的方法实现不一样，以及在多场景游戏中会需要有更换scene controller的方法。此处使用跟之前一样的。挂载在相机上的usergui作为与用户唯一有互动的门面，通过IUserAction接口调用scene controller中管理与用户互动的方法。制作本次游戏时，分析用户的动作得知，其中仅有点击开始按钮发送小球，实时显示得分以及显示最后得分的GUI，以及在upadate中检测鼠标点击目标并调用相应击中小球的动作接口的方法。挂载在一个空游戏对象上的scene controller，实际上也是一个场景只有一个实例，因为其他类都是通过调用单例模式的director中储存的ISceneController接口，来调用scene controller中管理与游戏内容的方法。其中存储着各种游戏中需要调用的常量与游戏状态的枚举常量，负责加载本场景中的游戏资源，以及与usergui、action manager、工厂、计分器的任务交接分配。在点击小球游戏中，游戏开始作为与用户互动的方法是在usergui中被调用，从工厂中拿出加载好的小球，并在action manager的管理下开始动作；击中小球的方法也是在usergui中被调用，在工厂中将小球的material更改并提醒计分器计分；归还小球的方法则是在action manager中被调用，将小球归还到工厂中，并判断能否开启下一round的游戏。此外，还有一些被usergui调用的获得当前游戏状态的方法。与scene controller一样挂载在一个空对象上的action manager，与其action manager基类的唯一区别就是实现action完成的回调时的实现，此处是将完成动作的小球通过调用scene controller中的方法归还给工厂。个人理解，此处应该另外抽象出一部分scene controller的方法作为接口给action manager调用，而不是像我这里是直接存储了一个实例的引用。action manager base基类存有一个当前正在进行的动作的字典，以及一个等待进行的列表跟一个等待删除列表。此类进行更新时，遍历等待进行的列表将对应动作加入字典，遍历正在进行的动作将其更新并判断是否完成，遍历等待删除的动作将其删除。外部需要进行动作时，调用其中的run action方法将相应动作与进行动作的游戏对象绑定，并加入等待列表。action基类属性包括进行动作的游戏对象与目标transform、动作完成时回调的接口，以及是否被激活、是否需要被删除的标签。所有继承此基类的动作类需要实现自己的更新方法。本游戏中唯一的动作类类似move to action，为单一动作类，属性包括x方向的速度与y方向加速度、y方向的速度，获取实例时通过随机数定义该动作的初始x速度与y方向的加速度；动作进行更新时，游戏对象（小球）进行抛物线运动。同样挂载在空游戏对象上的工厂类存储有空闲与使用中的两个小球列表，以及小球使用的材质列表。工厂类在awake时即将可能用到的空闲小球全部加载完毕，需要使用时通过使用函数取用，归还时通过归还函数归还，并且需要一个改变小球材质的函数，获取当前空闲小球列表是否为空的函数供scene controller调用获得当前工厂状态。同样挂载在空游戏对象上的计分器比较简单，只需要控制分数增加。